
# ErgoScript Compiler Phases

This document provides an overview of the key phases in the ErgoScript compiler pipeline, along with specific implementations in the sigma-rust and sigmastate-interpreter projects. The ErgoScript compiler takes high-level ErgoScript code and translates it into an intermediate form that can be evaluated by the ErgoTree interpreter or serialized for execution in the Ergo blockchain.

1. Lexical Analysis (Lexer)
2. Syntax Analysis (Parser)
    1. High-Level Intermediate Representation (HIR)
    2. Binding (Binder)
    3. Type Inference
    4. Middle Intermediate Representation (MIR)
    5. Type Checking
    6. Execution (ErgoTree Interpreter)

### 1. Lexer

**Objective**: The Lexer, also known as the tokenizer, is responsible for scanning the source code and converting it into a sequence of tokens. Tokens are the smallest meaningful elements in the code, such as keywords, operators, literals, and identifiers.

- **How it works**: The Lexer reads the input source code character by character and groups them into tokens. These tokens are categorized and labeled for the parser to consume.
- **Example**: Keywords like `if`, `else`, or operators like `+`, `-`, are converted into tokens that represent these elements in the language.

- **In `sigma-rust`**: The Lexer is implemented using the `Logos` crate, which provides a highly efficient way to define lexing rules in Rust.
  - **Location**: [`ergoscript-compiler/src/lexer.rs`](https://github.com/ergoplatform/sigma-rust/blob/develop/ergoscript-compiler/src/lexer.rs)

- **In `sigmastate-interpreter`**: A custom Scala-based Lexer is used for tokenization.
  - **Location**: [`parsers/shared/src/main/scala/sigmastate/lang/Lexer.scala`](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/parsers/shared/src/main/scala/sigmastate/lang/Lexer.scala)

### 2. Parser

**Objective**: The Parser takes the list of tokens generated by the Lexer and constructs an Abstract Syntax Tree (AST). The AST represents the syntactical structure of the source code in a tree format, where each node corresponds to a language construct like expressions, statements, or functions.

- **How it works**: The parser traverses the tokens in a predefined grammatical order to build the AST. This process involves ensuring that the source code follows the syntax rules of the language.
- **Example**: An expression like `a + b` would be represented as a node in the AST with `+` as the root, and `a` and `b` as its children.

- **In `sigma-rust`**: The parser uses the `Rowan` library to manage Concrete Syntax Trees (CST) and Abstract Syntax Trees (AST). AST nodes wrap Rowanâ€™s trees and expose node-specific details through methods.
  - **Location**: [`ergoscript-compiler/src/parser.rs`](https://github.com/ergoplatform/sigma-rust/blob/develop/ergoscript-compiler/src/parser.rs)

- **In `sigmastate-interpreter`**: The Scala implementation utilizes its own parsing strategies to construct the AST from tokens.
  - **Location**: [`parsers/shared/src/main/scala/sigmastate/lang/SigmaParser.scala`](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/parsers/shared/src/main/scala/sigmastate/lang/SigmaParser.scala)

### 3. High-level Intermediate Representation (HIR)

**Objective**: The HIR is an intermediate step that simplifies the AST by abstracting away certain syntactical details while retaining the logical structure of the code. The HIR is more conducive to further analysis and transformation.

- **How it works**: The AST is transformed into HIR by "lowering" its structure, which means simplifying and standardizing the representation while retaining all necessary information for the subsequent compilation phases.
- **Example**: Complex language constructs in the AST are reduced to simpler, more uniform representations in the HIR.

- **In `sigma-rust`**: Each HIR node has a kind (enum), span (source code reference), and an optional type. This makes it easier to perform operations like type inference and binding.
  - **Location**: [`ergoscript-compiler/src/hir.rs`](https://github.com/ergoplatform/sigma-rust/blob/develop/ergoscript-compiler/src/hir.rs)

- **In `sigmastate-interpreter`**: HIR serves a similar purpose, with emphasis on compatibility with the Scala language's functional programming features.
  - **Location**: [`sc/shared/src/main/scala/sigma/compiler/ir/TypeDescs.scala`](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/sc/shared/src/main/scala/sigma/compiler/ir/TypeDescs.scala)

### 4. Binder

**Objective**: The Binder phase resolves and links identifiers in the HIR to their corresponding definitions. This includes resolving variables, functions, and constants to ensure that the script's logic is correctly mapped to the underlying data structures.

- **How it works**: The Binder traverses the HIR and replaces symbolic names with actual references. This process involves checking the environment (like global variables and predefined constants) and linking them appropriately.
- **Example**: An identifier like `HEIGHT` in a script would be resolved to the actual block height from the environment.

- **In `sigma-rust`**: The Binder rewrites the HIR, swapping identifiers and variables with their respective HIR nodes, ensuring correct references.
  - **Location**: [`ergoscript-compiler/src/binder.rs`](https://github.com/ergoplatform/sigma-rust/blob/develop/ergoscript-compiler/src/binder.rs)

- **In `sigmastate-interpreter`**: A similar process is implemented in Scala, using the Scala language's features for name resolution and binding.
  - **Location**: [`sc/shared/src/main/scala/sigma/compiler/phases/SigmaBinder.scala`](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/sc/shared/src/main/scala/sigma/compiler/phases/SigmaBinder.scala)

### 5. Type Inference

**Objective**: Type Inference is the phase where the compiler determines the types of all expressions in the script. This ensures that all operations in the script are type-safe, meaning they are performed on compatible types.

- **How it works**: The Type Inference algorithm recursively analyzes the HIR and assigns types to each expression. It checks for type consistency and infers types where they are not explicitly provided.
- **Example**: In a script, if an integer is added to a floating-point number, the type inference will ensure that the operation is valid and determine the result's type.

- **In `sigma-rust`**: Type inference is implemented as a separate phase that traverses the HIR and assigns types, ensuring type correctness before moving to the next phase.
  - **Location**: [`ergoscript-compiler/src/type_infer.rs`](https://github.com/ergoplatform/sigma-rust/blob/develop/ergoscript-compiler/src/type_infer.rs)

- **In `sigmastate-interpreter`**: Type inference follows Scala's type system rules, ensuring that all expressions are type-safe.
  - **Location**: [`sc/shared/src/main/scala/sigma/compiler/phases/SigmaTyper.scala`](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/sc/shared/src/main/scala/sigma/compiler/phases/SigmaTyper.scala)

### 6. Middle-level Intermediate Representation (MIR)

**Objective**: MIR is a lower-level intermediate representation that is closer to machine code or the final bytecode. It is generated by further refining the HIR, simplifying and optimizing the representation for execution.

- **How it works**: The MIR is generated by lowering the HIR, performing transformations and optimizations that prepare the code for execution. This phase involves removing redundant operations and simplifying complex constructs.
- **Example**: Complex expressions might be broken down into simpler operations that are easier to optimize and execute.

- **In `sigma-rust`**: MIR is the final form of the IR used by the interpreter and for serialization purposes.
  - **Location**: [`ergotree-ir/src/mir.rs`](https://github.com/ergoplatform/sigma-rust/blob/develop/ergotree-ir/src/mir.rs)

- **In `sigmastate-interpreter`**: MIR serves a similar role, focusing on preparing the script for evaluation by the ErgoTree interpreter.
  - **Location**: [`sc/shared/src/main/scala/sigma/compiler/ir/ProgramGraphs.scala`](https://github.com/ScorexFoundation/sigmastate-interpreter/blob/develop/sc/shared/src/main/scala/sigma/compiler/ir/ProgramGraphs.scala)

### 7. Type Checking

**Objective**: Type Checking ensures that the types of all expressions and operations in the MIR are consistent and correct. This phase verifies that the script adheres to the type rules established during type inference.

- **How it works**: The Type Checker traverses the MIR, checking that each operation's input types are compatible with its output types, and ensuring that the script is type-safe.
- **Example**: The Type Checker would flag an error if a string were incorrectly used in a numerical operation.

- **In `sigma-rust`**: Type checking is performed

 alongside the MIR traversal, validating the correctness of the types before the script is executed.
 